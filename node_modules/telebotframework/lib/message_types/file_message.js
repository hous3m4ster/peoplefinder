"use strict";

/************
 * Requires *
 ************/

var Message = require("./message");
var fs = require("fs");

/*************************
 * The FileMessage class *
 *************************/

/**
 * A message which contains a downloadable file, like a document or photo
 *
 * @extends Message
 */
class FileMessage extends Message {
	/**
	 * Creates a new FileMessage object
	 *
	 * @param {Object}Â message	A raw message object from an update
	 * @param {BotAPI} API	An instance of a BotAPI from teleapiwrapper which will be used to do stuff with this message
	 *
	 * @private
	 */
	constructor(message, API) {
		// Call the super constructor
		super(message, API);

		// Check if the message is actually a file message
		/**
		 * ID of the file in this message
		 *
		 * @private
		 */
		this._fileId = null;
		if (this.rawMessage.audio !== undefined) {
			this._fileId = this.rawMessage.audio.file_id;
		} else if (this.rawMessage.document !== undefined) {
			this._fileId = this.rawMessage.document.file_id;
		} else if (this.rawMessage.photo !== undefined) {
			// This will contain multiple images. AFAIK the last in the array is the original
			let photo = this.rawMessage.photo;
			this._fileId = photo[photo.length-1].file_id;
		} else if (this.rawMessage.sticker !== undefined) {
			this._fileId = this.rawMessage.sticker.file_id;
		} else if (this.rawMessage.video !== undefined) {
			this._fileId = this.rawMessage.video.file_id;
		} else if (this.rawMessage.voice !== undefined) {
			this._fileId = this.rawMessage.voide.file_id;
		}

		/**
		 * Info about the file in the form of a promise. Will be null before getFileInfo has been called
		 *
		 * @private
		 */
		this._fileInfoPromise = null;
	}

	/**
	 * The ID of the file in this message
	 *
	 * @type {String}
	 * @readonly
	 */
	get fileId() {
		return this._fileId;
	}

	/**
	 * Info about the file in the form of a promise which resolves to a [File]{@link https://core.telegram.org/bots/api#file} object
	 *
	 * @type {Promise}
	 * @readonly
	 */
	get fileInfoPromise() {
		if (this._fileInfoPromise === null) {
			this._fileInfoPromise = this._API.getFile(this._fileId);
		}
		return this._fileInfoPromise;
	}

	/**
	 * Downloads the file and puts it in a buffer. Be careful about using this method with large files
	 *
	 * @return {Promise}	A promise which resolves with a buffer containing the file when the file is downloaded
	 */
	getFile() {
		return this.getFileStream().then(fileStream => {
			return new Promise((resolve, reject) => {
				let buffer = null;
				fileStream.on("data", chunk => {
					if (buffer === null) {
						buffer = chunk;
					} else {
						buffer = buffer.concat(chunk);
					}
				});
				fileStream.on("end", () => resolve(buffer));
				fileStream.on("error", reject);
			});
		});
	}

	/**
	 * Gets a http stream to the file
	 *
	 * @return {Promise}	A promise which resolves with a stream containing the file
	 */
	getFileStream() {
		return this.fileInfoPromise.then(file => {
			return this._API.helperDownloadFile(file)
		});
	}


	/**
	 * Saves the file to disk
	 *
	 * @param {String} filename	The filename to save the file to 
	 *
	 * @return {Promise}	A promise which resolves when the file is saved
	 */
	saveFile(filename) {
		return this.getFileStream().then(fileStream => {
			return new Promise((resolve, reject) => {
				let ws = fs.createWriteStream(filename);

				fileStream.pipe(ws);
				ws.on("error", reject);
				fileStream.on("error", reject);
				fileStream.on("end", resolve);
			});
		});
	}
}

/***********
 * Exports *
 ***********/

module.exports = FileMessage;

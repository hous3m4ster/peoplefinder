"use strict";

/************
 * Requires *
 ************/

var EventEmitter = require("events").EventEmitter;
var Message = require("./message_types/index").Message;

/****************************
 * The UpdateGetter class *
 ***************************/

/**
 * Listens for updates to a telegram bot using the getUpdates-method of the API. Start it with the startLongpolling() method, and stop it with the stopLongpolling() method, or give it an array of updates received from a webhook or other sources through the processUpdates() method. Fires events on incoming updates. There is an "error" event, for any errors, "message", "inline_query" and "chosen_inline_result" events for the specific types of updates, and a generic "update" event, giving you the whole update object of all updates
 *
 * @extends EventEmitter
 */
class UpdateGetter extends EventEmitter {
	/**
	 * Creates a new update emitter which gets updates for the bot given
	 *
	 * @param {BotAPI} api	The api to get updates for. Should be a api from [teleapiwrapper]{@link https://www.npmjs.com/package/teleapiwrapper}
	 */
	constructor(api) {
		super();
		/**
		 * The api to get updates for
		 *
		 * @private
		 */
		this._API = api;
		/**
		 * ID of the last received update, to get the offset right
		 *
		 * @private
		 */
		this._lastUpdateId = 0;
		/**
		 * Tells the callback whether or not to send another getUpdates-request
		 *
		 * @private
		 */
		this._keepListening = false;
		/**
		 * Controls how long getUpdates() will poll before declaring a timeout, in seconds
		 *
		 * @private
		 */
		this._longpollingTimeout = 60;
	}

	
	/**
	 * The api this listener gets updates for. An instance of teleapiwrapper's [BotAPI]{@link https://doc.suppen.no/teleapiwrapper/BotAPI.html}
	 *
	 * @type {BotAPI}
	 * @readonly
	 */
	get API() {
		return this._API;
	}

	/**
	 * Max time to poll for updates before giving up. Unless the listener is stopped, a new request will be sent almost immediately. Setting this to a high number will reduce the load on your network, but may cause other problems. Don't use it unless you know what it is
	 *
	 * @type {Integer}
	 */
	get longpollingTimeout() {
		return this._longpollingTimeout;
	}
	set longpollingTimeout(secs) {
		let parsedSecs = Number(secs);
		if (Number.isNaN(parsedSecs)) {
			console.warn(secs + " is not a number nor convertible to a number. Setting timeout to 60 seconds");
			parsedSecs = 60;
		}
		this._longpollingTimeout = Math.floor(Math.abs(parsedSecs));
	}

	/**
	 * Sends a getUpdates-request
	 *
	 * @private
	 */
	_listen() {
		this._API.getUpdates({
			offset: this._lastUpdateId+1,
			timeout: this._longpollingTimeout,
		}).then(updates => {
			// Check if the listener is stopped
			if (!this._keepListening) {
				// Stopped. Don't process the result
				return;
			}

			// Process the updates
			this._processUpdates(updates);

			// Listen again, if it still should
			if (this._keepListening) {
				this._listen();
			}
		}).catch(err => {
			if (this._keepListening) {
				if (this.listenerCount("error") == 0) {
					// Errors can't be thrown out of a promise chain. Must display it here
					console.error(err.stack);
					console.info("To handle this error, add a listener to the 'error' event");
				} else {
					/**
					 * Error event, if anything went wrong while listening or processing updates
					 *
					 * @event UpdateGetter#error
					 * @memberof UpdateGetter
					 * @param {Error} error	The error object
					 */
					this.emit(err);
				}
				this._listen();
			}
		});
	}

	/**
	 * Processes update objects and fires events based on them. Useful if you prefer to use webhooks over long polling. Just send the update array to this method. Calling this method will automatically stop long polling if it is running
	 *
	 * @param {Object[]} updates	An array of [update]{@link https://core.telegram.org/bots/api#update} objects, possibly received from a webhook
	 */
	processUpdates(updates) {
		this.stopLongpolling();
		this._processUpdates(updates);
	}

	/**
	 * The actual method which processes updates. Please do not use directly
	 *
	 * @private
	 * @param {Object[]} updates	An array of update objects
	 */
	_processUpdates(updates) {
		// Process the updates
		updates.forEach(update => {
			// Update the offset
			this._lastUpdateId = Math.max(update.update_id, this._lastUpdateId);

			/**
			 * Fires on all received updates
			 *
			 * @event UpdateGetter#update
			 * @memberof UpdateGetter
			 * @param {Object} update	The [update]{@link https://core.telegram.org/bots/api#update} received
			 */
			this.emit("update", update);

			// Check what type of message this is
			if (typeof update.message != "undefined") {
				let m = new Message(update.message, this.API);
				/**
				 * Fires when the bot receives a message
				 *
				 * @event UpdateGetter#message
				 * @memberof UpdateGetter
				 * @param {Message} message	The [message]{@link https://core.telegram.org/bots/api#message} received, wrapped in a [Message]{@link Message} class
				 */
				this.emit("message", m);
			} else if (typeof update.inline_query != "undefined") {
				/**
				 * Fires when the bot receives an inline query
				 *
				 * @event UpdateGetter#inline_query
				 * @memberof UpdateGetter
				 * @param {Object} inline_query	The [inline query]{@link https://core.telegram.org/bots/api#inlinequery} received
				 */
				this.emit("inline_query", update.inline_query);
			} else if (typeof update.chosen_inline_result != "undefined") {
				/**
				 * Fires when a user has chosen an inline result from the bot
				 *
				 * @event UpdateGetter#chosen_inline_result
				 * @memberof UpdateGetter
				 * @param {Object} chosen_inline_result	The [inline result]{@link https://core.telegram.org/bots/api#choseninlineresult} chosen
				 */
				this.emit("chosen_inline_result");
			}
		});
	}

	/**
	 * Starts longpolling for updates, if not already started
	 */
	startLongpolling() {
		if (this._listenTimeout == null) {
			this._keepListening = true;
			this._listen();
		}
	}

	/**
	 * Stop longpolling, if started
	 */
	stopLongpolling() {
		if (this._keepListening == true) {
			clearTimeout(this._listenTimeout);
			this._keepListening = false;
		}
	}
}

/***********
 * Exports *
 ***********/

module.exports = UpdateGetter;
